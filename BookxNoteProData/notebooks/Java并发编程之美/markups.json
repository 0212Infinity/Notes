{"EpubVersion":2,"filepath":"","floatingtheme":[],"folded":false,"markups":[{"date":"2022-07-03 21:43:51","docid":0,"fillcolor":"ffffed99","folded":true,"id":5,"linecolor":"ffff0000","markups":[{"date":"2022-07-03 21:45:49","docid":0,"fillcolor":"ffffed99","id":6,"linecolor":"ffff0000","originaltext":"看源码可以扩展我们的思路，这是变相增加我们经验的不错方法","page":6,"textblocks":[{"first":[344.0099792480469,317.51995849609375,10.3599853515625,8.6400146484375],"last":[217.54916381835938,335.2699890136719,10.461196899414062,8.399993896484375],"length":29,"rects":[[344.0099792480469,317.51995849609375,114.88003540039062,8.6400146484375],[50.16999816894531,335.2699890136719,177.84036254882812,8.399993896484375]],"start":381,"text":"看源码可以扩展我们的思\n路，这是变相增加我们经验的不错方法"}],"type":5,"underline":true,"uuid":"ee821a2eefc3c47da25b2456d3231582"},{"date":"2022-07-03 21:46:14","docid":0,"fillcolor":"ffffed99","id":7,"linecolor":"ffff0000","originaltext":"对阅读源码有经验，那么在研究新系统的代码逻辑时就不会那么费劲了","page":6,"textblocks":[{"first":[155.06190490722656,393.3499755859375,10.407302856445312,8.8800048828125],"last":[59.769996643066406,411.1099853515625,9.599998474121094,8.8800048828125],"length":32,"rects":[[155.06190490722656,393.3499755859375,303.82801818847656,8.8800048828125],[50.16999816894531,411.1099853515625,19.199996948242188,8.8800048828125]],"start":502,"text":"对阅读源码有经验，那么在研究新系统的代码逻辑时就不会那么费\n劲了"}],"type":5,"underline":true,"uuid":"7803e20fcebea7a794e21bb1bb48ddad"},{"date":"2022-07-03 21:47:46","docid":0,"fillcolor":"ffffed99","id":8,"linecolor":"ffff0000","originaltext":"人是善忘的，一段时间不使用，就会忘记它们的区别，当你再去使用时,需进入方法的内部, 看它们的源码实现","page":6,"textblocks":[{"first":[400.44000244140625,504.7099609375,9.540008544921875,9.1199951171875],"last":[296.45379638671875,522.469970703125,10.16729736328125,8.8800048828125],"length":32,"rects":[[400.44000244140625,504.7099609375,57.24005126953125,9.1199951171875],[50.40999984741211,522.469970703125,256.2110939025879,8.8800048828125]],"start":749,"text":"人是善忘的，\n一段时间不使用，就会忘记它们的区别，当你再去使用时"}],"type":5,"underline":true,"uuid":"7ad1c5031581b29a721f0ffc18334389"},{"date":"2022-07-03 21:49:22","docid":0,"fillcolor":"ffffed99","id":12,"linecolor":"ffff0000","originaltext":"看源码最大的好处是可以开阔思维，提升架构设计能力","page":7,"textblocks":[{"first":[73.68000030517578,80.86994934082031,10.480003356933594,8.639999389648438],"last":[315.0600280761719,80.86994934082031,10.3800048828125,8.639999389648438],"length":24,"rects":[[73.68000030517578,80.86994934082031,251.7600326538086,8.639999389648438]],"start":23,"text":"看源码最大的好处是可以开阔思维，提升架构设计能力"}],"type":5,"underline":true,"uuid":"f0a47ce17e46fd4e976b363b72502cbe"}],"originaltext":"为什么要看源码","page":6,"textblocks":[{"first":[49.91999816894531,117.83997344970703,12.78860092163086,10.319999694824219],"last":[126.6515884399414,117.83997344970703,12.788597106933594,10.319999694824219],"length":7,"rects":[[49.91999816894531,117.83997344970703,89.52018737792969,10.319999694824219]],"start":45,"text":"为什么要看源码"}],"type":5,"underline":true,"uuid":"53785e5609bba080042577e3746419c0","width":351},{"date":"2022-07-03 21:50:24","docid":0,"fillcolor":"ffffed99","folded":true,"id":13,"linecolor":"ffff0000","markups":[{"date":"2022-07-03 21:51:24","docid":0,"fillcolor":"ffffed99","id":14,"linecolor":"ffff0000","originaltext":"去Google查找这个开源框架的官方介绍，通过资料了解该框架有几个模块，各个模块是做什么的，之间有什么联系，每个模块都有哪些核心类，在阅读源码时可以着重看这些类","page":7,"textblocks":[{"first":[328.3299865722656,204.469970703125,10.55999755859375,8.399993896484375],"last":[314.5449523925781,239.50997924804688,10.42498779296875,8.399993896484375],"length":82,"rects":[[328.3299865722656,204.469970703125,134.14999389648438,8.399993896484375],[54.25,221.74998474121094,406.5607604980469,8.639999389648438],[53.7599983215332,239.50997924804688,271.2099418640137,8.399993896484375]],"start":236,"text":"去Google查找这个开源框架\n的官方介绍，通过资料了解该框架有几个模块，各个模块是做什么的，之间有什么联系，\n每个模块都有哪些核心类，在阅读源码时可以着重看这些类"}],"type":5,"underline":true,"uuid":"1673a70de6eb0a41526ba76a9bd16b8e"},{"date":"2022-07-03 21:51:35","docid":0,"fillcolor":"ffffed99","id":15,"linecolor":"ffff0000","originaltext":"哪个模块感兴趣就去写个小demo,debug进入看里面的具体实现","page":7,"textblocks":[{"first":[105.3258056640625,262.54998779296875,10.62860107421875,8.8800048828125],"last":[255.1300048828125,262.54998779296875,4.560089111328125,8.8800048828125],"length":16,"rects":[[105.3258056640625,262.54998779296875,154.36428833007812,8.8800048828125]],"start":323,"text":"哪个模块感兴趣就去写个小demo"}],"type":5,"underline":true,"uuid":"e0d2de882fa586a66cbf2fc631d52160"},{"date":"2022-07-03 21:53:23","docid":0,"fillcolor":"ffffed99","id":16,"linecolor":"ffff0000","originaltext":"开源框架的注释是一手资料","page":7,"textblocks":[{"first":[357.4500732421875,408.949951171875,10.480010986328125,8.8800048828125],"last":[420.33013916015625,408.949951171875,10.480010986328125,8.8800048828125],"length":7,"rects":[[357.4500732421875,408.949951171875,73.36007690429688,8.8800048828125]],"start":658,"text":"注释是一手资料"}],"type":5,"underline":true,"uuid":"5e7965829beaff2c07df40e6242b12cf"},{"date":"2022-07-03 21:54:23","docid":0,"fillcolor":"ffffed99","id":17,"linecolor":"ffff0000","originaltext":"查框架使用说明最好去官网查","page":7,"textblocks":[{"first":[105.16799926757812,526.0799560546875,10.736000061035156,8.8800048828125],"last":[235.92999267578125,526.0799560546875,9.360000610351562,8.8800048828125],"length":13,"rects":[[105.16799926757812,526.0799560546875,140.1219940185547,8.8800048828125]],"start":840,"text":"查框架使用说明最好去官网查"}],"type":5,"underline":true,"uuid":"10d8fe423462f2a84043f235e1686095"}],"originaltext":"如何看源码","page":7,"textblocks":[{"first":[53.7599983215332,179.26995849609375,12.768001556396484,10.32000732421875],"last":[104.83199310302734,179.26995849609375,12.767997741699219,10.32000732421875],"length":5,"rects":[[53.7599983215332,179.26995849609375,63.83999252319336,10.32000732421875]],"start":206,"text":"如何看源码"}],"type":5,"underline":true,"uuid":"12345a8c70f262186b6126f09a48c617"},{"date":"2022-07-03 21:55:40","docid":0,"fillcolor":"ffffed99","folded":false,"id":18,"linecolor":"ffff0000","markups":[{"date":"2022-07-03 21:57:51","docid":0,"fillcolor":"ffffed99","folded":true,"id":19,"linecolor":"ffff0000","markups":[{"date":"2022-07-03 21:58:29","docid":0,"fillcolor":"ffffed99","id":20,"linecolor":"ffff0000","originaltext":"一个进程中至少有一个线程，进程中的多个线程共享进程的资源。","page":16,"textblocks":[{"first":[293.04998779296875,316.5599670410156,9.3599853515625,8.6400146484375],"last":[172.41000366210938,333.8299560546875,8.080001831054688,8.8800048828125],"length":30,"rects":[[293.04998779296875,316.5599670410156,167.02999877929688,8.6400146484375],[51.599998474121094,333.8299560546875,128.89000701904297,8.8800048828125]],"start":124,"text":"一个进程中至少有一个线程，进程中\n的多个线程共享进程的资源。"}],"type":5,"underline":true,"uuid":"fc055e11f876213e98a4e381faa4cd9d"},{"date":"2022-07-03 21:58:43","docid":0,"fillcolor":"ffffed99","id":21,"linecolor":"ffff0000","originaltext":"操作系统在分配资源时是把资源分配给进程的","page":16,"textblocks":[{"first":[72,357.3499755859375,9.599998474121094,8.6400146484375],"last":[276.489990234375,357.3499755859375,6.239990234375,8.6400146484375],"length":20,"rects":[[72,357.3499755859375,210.72998046875,8.6400146484375]],"start":155,"text":"操作系统在分配资源时是把资源分配给进程的"}],"type":5,"underline":true,"uuid":"b46ec346c8e0ff7d07f6a21f271babcc"},{"date":"2022-07-03 21:59:10","docid":0,"fillcolor":"ffffed99","id":22,"linecolor":"ffff0000","originaltext":"CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是CPU分配的基本单位。","page":16,"textblocks":[{"first":[320.8900146484375,357.3499755859375,6.6400146484375,8.6400146484375],"last":[450.46002197265625,374.6299743652344,9.6300048828125,9.1199951171875],"length":56,"rects":[[320.8900146484375,357.3499755859375,139.91998291015625,8.6400146484375],[51.130001068115234,374.6299743652344,408.9600257873535,9.1199951171875]],"start":178,"text":"CPU资源比较特殊，它是被分\n配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是CPU分配的基本单位。"}],"type":5,"underline":true,"uuid":"f3814f35b82407fbf0ca21a95a53d13e"},{"date":"2022-07-03 22:11:39","docid":0,"fillcolor":"ffffed99","id":23,"linecolor":"ffff0000","originaltext":"一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和技区域","page":17,"textblocks":[{"first":[161.0399932861328,82.80001068115234,9.360000610351562,8.400001525878906],"last":[233.7357635498047,100.0699691772461,10.354293823242188,8.400001525878906],"length":48,"rects":[[161.0399932861328,82.80001068115234,291.8407745361328,8.400001525878906],[45.849998474121094,100.0699691772461,198.24005889892578,8.400001525878906]],"start":25,"text":"一个进程中有多个线程，多个线程共享进程的堆和方法区资源，\n但是每个线程有自己的程序计数器和技区域"}],"type":5,"underline":true,"uuid":"21b7d92ebfbac487c71d440828a0a2ca"},{"date":"2022-07-03 22:15:22","docid":0,"fillcolor":"ffffed99","id":24,"linecolor":"ffff0000","originaltext":"程序计数器, 执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是Java代码时pc计数器记录的才是下一条指令的地址","page":17,"textblocks":[{"first":[357.6634216308594,209.50999450683594,9.946685791015625,8.639999389648438],"last":[118.7199935913086,245.03001403808594,9.920005798339844,8.639999389648438],"length":69,"rects":[[357.6634216308594,209.50999450683594,94.986572265625,8.639999389648438],[45.849998474121094,226.79000854492188,408.70996856689453,8.8800048828125],[46.33000183105469,245.03001403808594,82.30999755859375,8.639999389648438]],"start":304,"text":"执行的是native方法，\n那么pc计数器记录的是undefined地址，只有执行的是Java代码时pc计数器记录的才是\n下一条指令的地址"}],"type":5,"underline":true,"uuid":"3a08a8432c2b7e2b7dc3d84eb3bbe093"},{"date":"2022-07-03 22:20:47","docid":0,"fillcolor":"ffffed99","id":25,"linecolor":"ffff0000","originaltext":"每个线程都有自己的战资源，用于存储该线程的局部变量","page":17,"textblocks":[{"first":[87.83999633789062,268.0699768066406,9.599998474121094,8.6400146484375],"last":[339.6099853515625,268.0699768066406,9.839996337890625,8.6400146484375],"length":25,"rects":[[87.83999633789062,268.0699768066406,261.6099853515625,8.6400146484375]],"start":377,"text":"每个线程都有自己的战资源，用于存储该线程的局部变量"}],"type":5,"underline":true,"uuid":"5df2521f2ed150c2b0fbfcc95012dee5"},{"date":"2022-07-03 22:21:01","docid":0,"fillcolor":"ffffed99","id":26,"linecolor":"ffff0000","originaltext":"堆是被进程中的所有线程共享的","page":17,"textblocks":[{"first":[224.04078674316406,308.8699951171875,10.467697143554688,8.6400146484375],"last":[360.1210021972656,308.8699951171875,10.46771240234375,8.6400146484375],"length":14,"rects":[[224.04078674316406,308.8699951171875,146.5479278564453,8.6400146484375]],"start":463,"text":"堆是被进程中的所有线程共享的"}],"type":5,"underline":true,"uuid":"3e5e9018aa3d3bab9f944cdd579207ef"},{"date":"2022-07-03 22:21:05","docid":0,"fillcolor":"ffffed99","id":27,"linecolor":"ffff0000","originaltext":"方法区则用来存放NM加载的类、常量及静态变量等信息，也是线程共享","page":17,"textblocks":[{"first":[67.19999694824219,349.20001220703125,10.290000915527344,9.1199951171875],"last":[396,349.20001220703125,9.839996337890625,9.1199951171875],"length":32,"rects":[[67.19999694824219,349.20001220703125,338.63999938964844,9.1199951171875]],"start":512,"text":"方法区则用来存放NM加载的类、常量及静态变量等信息，也是线程共享"}],"type":5,"underline":true,"uuid":"86908fe60a2847150ae41afdda9c9de8"}],"originaltext":"什么是线程","page":16,"textblocks":[{"first":[91.44000244140625,252.95999145507812,16.751998901367188,13.67999267578125],"last":[158.447998046875,252.95999145507812,16.751998901367188,13.67999267578125],"length":5,"rects":[[91.44000244140625,252.95999145507812,83.75999450683594,13.67999267578125]],"start":17,"text":"什么是线程"}],"type":5,"underline":true,"uuid":"f9a7170180be37e6e753175be99242cf"},{"date":"2022-07-03 22:49:27","docid":0,"fillcolor":"ffffed99","id":28,"linecolor":"ffff0000","markups":[{"date":"2022-07-03 22:49:41","docid":0,"fillcolor":"ffffed99","id":29,"linecolor":"ffff0000","originaltext":"Java中有三种线程创建方式，分别为实现Runnable接口的run方法，继承Thread类并重写run的方法，使用Fu阳reTask方式","page":17,"textblocks":[{"first":[66.72000122070312,413.2699890136719,3.5999984741210938,8.6400146484375],"last":[221.41000366210938,430.54998779296875,9.960006713867188,8.8800048828125],"length":70,"rects":[[66.72000122070312,413.2699890136719,387.8500061035156,8.6400146484375],[46.09000015258789,430.54998779296875,185.28001022338867,8.8800048828125]],"start":559,"text":"Java中有三种线程创建方式，分别为实现Runnable接口的run方法，继承Thread类\n并重写run的方法，使用Fu阳reTask方式"}],"type":5,"underline":true,"uuid":"03c681093065c7e8738954e418db547d"},{"content":"run（）方法内获取当前线程直接使用this","date":"2022-07-03 22:59:09","docid":0,"fillcolor":"ffffed99","folded":false,"id":30,"linecolor":"ffff0000","markups":[{"date":"2022-07-03 22:59:24","docid":0,"fillcolor":"ffffed99","id":31,"linecolor":"ffff0000","originaltext":"重写了run（）方法","page":18,"textblocks":[{"first":[300.239990234375,220.79000854492188,10.239990234375,8.399993896484375],"last":[369.239990234375,220.79000854492188,10.44000244140625,8.399993896484375],"length":10,"rects":[[300.239990234375,220.79000854492188,79.44000244140625,8.399993896484375]],"start":150,"text":"重写了run（）方法"}],"type":5,"underline":true,"uuid":"754938494ef3bd2dde653d747186c321"},{"content":"其实调用start方法后线程并没有马上执行而是处于就绪状态，这个就绪状态是指该\n线程已经获取了除CPU资源外的其他资源，等待获取CPU资源后才会真正处于运行状态。\n一旦run方法执行完毕，该线程就处于终止状态","date":"2022-07-03 22:59:42","docid":0,"fillcolor":"ffffed99","id":32,"linecolor":"ffff0000","originaltext":"创建完thread对象后该线程并没有被启动执行","page":18,"textblocks":[{"first":[61.209999084472656,255.8300018310547,9.599998474121094,8.639999389648438],"last":[263.4939880371094,255.8300018310547,10.667999267578125,8.639999389648438],"length":23,"rects":[[61.209999084472656,255.8300018310547,212.95198822021484,8.639999389648438]],"start":218,"text":"创建完thread对象后该线程并没有被启动执行"}],"type":5,"underline":true,"uuid":"b7cc03be14ef5025421a49c8495bf130"}],"originaltext":"继承Thread类方式","page":17,"textblocks":[{"first":[98.16999816894531,454.07000732421875,10.080001831054688,8.6400146484375],"last":[174.72000122070312,454.07000732421875,10.32000732421875,8.6400146484375],"length":11,"rects":[[98.16999816894531,454.07000732421875,86.87001037597656,8.6400146484375]],"start":634,"text":"继承Thread类方式"}],"type":5,"underline":true,"uuid":"c4570694becb49069125f4d49a343961"},{"content":"1. 两个线程共用一个代码逻辑，如果需要，可以给RunableTask\n添加参数进行任务区分\n2. 可以继承其他类\n3. 缺点, 任务没有返回值","date":"2022-07-03 23:01:44","docid":0,"fillcolor":"ffffed99","id":33,"linecolor":"ffff0000","originaltext":"实现Runnable接口","page":18,"textblocks":[{"first":[289.3599548339844,407.510009765625,10.239990234375,8.8800048828125],"last":[365.2799987792969,407.510009765625,9.600006103515625,8.8800048828125],"length":12,"rects":[[289.3599548339844,407.510009765625,85.52005004882812,8.8800048828125]],"start":538,"text":"实现Runnable接口"}],"type":5,"underline":true,"uuid":"ae3bb33f81f4f07d41e8277fb9897e5f"},{"date":"2022-07-03 23:03:17","docid":0,"fillcolor":"ffffed99","id":35,"linecolor":"ffff0000","originaltext":"FutureTask的方式","page":19,"textblocks":[{"first":[345.6099853515625,118.55000305175781,4.4801025390625,8.639999389648438],"last":[414.010009765625,118.55000305175781,8.160003662109375,8.639999389648438],"length":13,"rects":[[345.6099853515625,118.55000305175781,76.56002807617188,8.639999389648438]],"start":151,"text":"FutureTask的方式"}],"type":5,"underline":true,"uuid":"0e665ffaccb80a74f367cc50bfc90d2c"}],"originaltext":"线程创建与运行","page":17,"textblocks":[{"first":[86.63999938964844,384.71002197265625,16.73149871826172,13.67999267578125],"last":[187.02902221679688,384.71002197265625,16.73150634765625,13.67999267578125],"length":7,"rects":[[86.63999938964844,384.71002197265625,117.12052917480469,13.67999267578125]],"start":551,"text":"线程创建与运行"}],"type":5,"underline":true,"uuid":"efdf1d1fd93ed67bdb482d0a2f9598e1"}],"originaltext":"并发编程线程基础","page":16,"textblocks":[{"first":[160.80999755859375,141.1099853515625,23.669998168945312,19.44000244140625],"last":[326.5000305175781,141.1099853515625,23.670013427734375,19.44000244140625],"length":8,"rects":[[160.80999755859375,141.1099853515625,189.36004638671875,19.44000244140625]],"start":4,"text":"并发编程线程基础"}],"type":5,"underline":true,"uuid":"342e807a83dd2bd603f9b1f97e1ec13e","width":351},{"content":"为什么传递给runnable的变量需要是最终的\nfinal int x = 0;//<----must be final\nprivate class myRun implements Runnable { @Override public void run() { x++;} }\n\n因为这就是语言规范所说的.根据Guy Steele的说法,这个选择背后的基本原理是程序员会期望int x = 0一个方法中的声明导致堆栈分配存储,但是如果你可以new myRun()从方法中返回一个(或者让一个myRun持久化的函数返回)并且你之后可以对其进行修改,然后x必须进行堆分配,以获得您期望的语义.\n他们本可以做到这一点,事实上其他语言就是这样做的.但是Java设计者决定要求你标记x为final避免要求实现堆分配看起来像堆栈分配的存储.\n(我应该注意:这不是特定于Runnable.它适用于任何匿名内部类.)","date":"2022-07-03 23:22:29","docid":0,"fillcolor":"ffffed99","id":37,"linecolor":"ffff0000","originaltext":"使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以","page":19,"textblocks":[{"first":[102.48999786376953,510.95001220703125,10.6885986328125,8.8800048828125],"last":[213.24998474121094,581.52001953125,10.199996948242188,8.6400146484375],"length":191,"rects":[[102.48999786376953,510.95001220703125,356.6403121948242,8.8800048828125],[49.439998626708984,528.7100219726562,409.2100257873535,8.8800048828125],[49.439998626708984,546,407.53000259399414,9.1199951171875],[49.439998626708984,563.75,408.97006607055664,8.8800048828125],[50.16999816894531,581.52001953125,173.2799835205078,8.6400146484375]],"start":809,"text":"使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过set\n方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线\n程里面被声明为final的变量。不好的地方是Java不支持多继承，如果继承了Thread类，\n那么子类不能再继承其他类，而Runable则没有这个限制。前两种方式都没办法拿到任务\n的返回结果，但是Futuretask方式可以"}],"title":"总结","type":5,"underline":true,"uuid":"059fa06b4eeb8a242d044b6aadebb0e9"}],"maxid":38,"notelinks":[],"title":"Java并发编程之美","unimportant":[{"date":"2022-07-03 21:37:44","docid":0,"highlighter":true,"id":3,"imgfile":"316598ca1cf8c2e33992c4bb0eb06975.png","linecolor":"fffeeb73","linewidth":16,"page":3,"parid":-1,"paridx":-1,"rect":[190.12499433383363,412.49998770654236,452.2499865219001,412.49998770654236,44.624998670071406,427.8749872483317,153.74999541789308,427.8749872483317],"type":1,"uuid":"beffbf6035e5e8926e8d4106bc333d4c"},{"date":"2022-07-03 21:43:38","docid":0,"highlighter":true,"id":4,"imgfile":"cd38e32a4f911f5358d5a40dbf88970b.png","linecolor":"fffeeb73","linewidth":16,"page":5,"parid":-1,"paridx":-1,"rect":[112.1249966584147,553.1249835155909,217.8749935068192,553.1249835155909],"type":1,"uuid":"b542a18b451a7c721070847a844e3694"},{"date":"2022-07-03 21:47:53","docid":0,"fillcolor":"ffffed99","id":10,"linecolor":"ffff0000","originaltext":"方法的内部，看它们的源码实现","page":6,"parid":-1,"paridx":-1,"textblocks":[{"first":[402.489990234375,522.469970703125,10.32000732421875,8.8800048828125],"last":[124.72000885009766,540.239990234375,10.650001525878906,8.6400146484375],"length":15,"rects":[[402.489990234375,522.469970703125,55.20001220703125,8.8800048828125],[50.16999816894531,540.239990234375,85.20001220703125,8.6400146484375]],"start":794,"text":"方法的内部，\n看它们的源码实现"}],"type":5,"underline":true,"uuid":"7f2baaa8af4ee6da65254f97f27f3e35"},{"date":"2022-07-03 21:49:09","docid":0,"fillcolor":"ffffed99","id":11,"linecolor":"ffff0000","originaltext":"需进入","page":6,"parid":-1,"paridx":-1,"textblocks":[{"first":[316.78839111328125,522.469970703125,10.16729736328125,8.8800048828125],"last":[337.12298583984375,522.469970703125,10.16729736328125,8.8800048828125],"length":3,"rects":[[316.78839111328125,522.469970703125,30.50189208984375,8.8800048828125]],"start":782,"text":"需进入"}],"type":5,"underline":true,"uuid":"83377c5c2ccd0adacff937a582163f7a"}]}